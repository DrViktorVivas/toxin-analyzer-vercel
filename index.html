<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Environmental Toxin Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        h1 {
            color: #8b0000; /* Dark Red for Toxin focus */
        }
        h2 {
            color: #555;
        }
        .file-upload-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            border: 2px dashed #a00;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            background-color: #ffeaea;
        }
        input[type="file"] {
            display: none;
        }
        .upload-label {
            background-color: #8b0000;
            color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        .upload-label:hover {
            background-color: #a52a2a;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .status-VERY_HIGH { color: #8b0000; font-weight: bold; }
        .status-HIGH { color: #ff8c00; font-weight: bold; }
        .status-ELEVATED { color: #ffd700; }
        .status-IN_RANGE { color: #28a745; }
        .btn-download {
            background-color: #0056b3;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        .btn-download:hover {
            background-color: #004080;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Environmental Toxin Analyzer</h1>
        <p id="mainInstruction">Upload your Ayus Lab report</p>

        <div class="file-upload-container">
            <p id="dictionaryStatus">Status: Loading Dictionary...</p>
            
            <input type="file" id="reportFile" accept=".pdf">
            <label for="reportFile" class="upload-label">Upload Toxin Report (PDF)</label>
            <p id="reportStatus">Status: Ready.</p>
            
            <button id="analyzeBtn" class="upload-label" style="background-color: #28a745; display: none;">RUN TOXIN ANALYSIS</button>
        </div>

        <div id="results" style="display: none;">
            <button id="downloadPdfBtn" class="btn-download">Download Toxin Risk Report (PDF)</button>
            <hr>
            
            <h2>Toxicity Risk Summary</h2>
            <div id="riskSummary"></div>
            
            <hr>

            <h2>Detailed Analyte Results</h2>
            <table id="analyteTable">
                <thead>
                    <tr>
                        <th>Analyte</th>
                        <th>Measurement</th>
                        <th>Reference (ULN)</th>
                        <th>Status</th>
                        <th>Ratio (Meas/Ref)</th>
                        <th>Key Health Effect</th>
                        <th>Primary Source</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';
        
        let dictionaryData = null;
        let reportData = null;
        let analysisResults = [];

        // --- Utility Functions ---

        const cleanText = (text) => text ? String(text).replace(/[\r\n\s\t]+/g, ' ').trim() : '';
        
        const parseValue = (text) => {
            if (!text) return NaN;
            let cleaned = text.replace(/[^0-9.,]/g, '');
            cleaned = cleaned.replace(',', '.');
            return parseFloat(cleaned);
        };
        
        // This function cleans the analyte name for reliable map key and search matching.
        const normalizeAnalyte = (name) => cleanText(name).toLowerCase().replace(/[\s\(\)\/&-]/g, '');

        // --- Dictionary & PDF Loading ---

        function loadDictionary() {
            // FIX: Fetch the CSV directly from the server path for Vercel deployment
            fetch('toxin-risk-dictionary.csv')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load dictionary. Status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            dictionaryData = new Map();
                            results.data.forEach(row => {
                                const normalizedName = normalizeAnalyte(row.Analyte);
                                if (normalizedName) {
                                    row.Ref_Value = parseValue(row.Ref_Value);
                                    row.Carcinogen = cleanText(row.Carcinogen);
                                    row.Neurotoxin = cleanText(row.Neurotoxin);
                                    dictionaryData.set(normalizedName, row);
                                }
                            });
                            // UI CLEANUP: Only show load status in the instruction section
                            document.getElementById('dictionaryStatus').textContent = `Dictionary loaded (${dictionaryData.size} analytes).`;
                            document.getElementById('reportStatus').textContent = `Status: Ready.`;
                            checkReady();
                        },
                        error: function(error) {
                            alert('Error parsing CSV dictionary: ' + error.message);
                        }
                    });
                })
                .catch(error => {
                    console.error("Dictionary Fetch Error:", error);
                    document.getElementById('dictionaryStatus').textContent = `âŒ ERROR: Could not load dictionary. Please check your file name.`;
                });
        }

        async function loadReport() {
            const file = document.getElementById('reportFile').files[0];
            if (!file) return;

            try {
                const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
                reportData = await extractToxinData(pdf);
                document.getElementById('reportStatus').textContent = `Status: Report parsed with ${reportData.length} analytes detected.`;
                checkReady();
            } catch (e) {
                console.error("PDF Parsing Error:", e);
                alert("Error parsing PDF. Check the console for details.");
            }
        }

        // --- PDF Toxin Data Extraction Logic (Most Robust Version) ---

        async function extractToxinData(pdf) {
            if (!dictionaryData || dictionaryData.size === 0) {
                 alert('Error: Dictionary not loaded. Cannot extract PDF data.');
                 return [];
            }
            
            const extractedAnalytes = [];
            const numPages = pdf.numPages;

            const normalizedToxinMap = new Map();
            Array.from(dictionaryData.values()).forEach(entry => {
                normalizedToxinMap.set(normalizeAnalyte(entry.Analyte), entry.Analyte);
            });
            
            // Iterate page by page, which is more reliable for complex table layouts
            for (let i = 1; i <= numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const textItems = textContent.items.map(item => ({ str: cleanText(item.str), transform: item.transform, width: item.width }));
                
                // Identify all potential analyte names on this page
                textItems.forEach((item, nameIndex) => {
                    const normalizedText = normalizeAnalyte(item.str);
                    
                    if (normalizedToxinMap.has(normalizedText)) {
                        const originalName = normalizedToxinMap.get(normalizedText);
                        
                        let candidates = [];
                        
                        // Search for ALL numeric candidates in the 30 subsequent items
                        for (let j = nameIndex + 1; j < textItems.length && j < nameIndex + 30; j++) {
                            const numericValue = parseValue(textItems[j].str);

                            if (!isNaN(numericValue) && numericValue > 0) {
                                candidates.push({ value: numericValue, index: j });
                            }
                            if (candidates.length >= 2) break; // Optimization: stop after two candidates found
                        }
                        
                        // Select the first two unique candidates as Reference and Measurement
                        if (candidates.length >= 2) {
                            extractedAnalytes.push({
                                Analyte: originalName,
                                Ref_Value_Report: candidates[0].value,
                                Measurement: candidates[1].value,
                            });
                        }
                    }
                });
            }
            
            // Filter the final list to keep only unique analytes
            const uniqueAnalytes = Array.from(new Set(extractedAnalytes.map(a => a.Analyte)))
                                        .map(name => extractedAnalytes.find(a => a.Analyte === name));
            return uniqueAnalytes;
        }


        // --- Core Toxin Risk Analysis Logic (Updated to Collect Toxin Names) ---

        function evaluateAnalytes() {
            analysisResults = [];
            // Initialize riskTally to store ARRAYS of analyte names for each system
            const riskTally = {
                'Neurological': [], 'Kidneys': [], 'Cardiovascular': [], 'Respiratory': [], 
                'Endocrine': [], 'Liver': [], 'Immune System': [], 'Bones/Skeleton': [],
                'Hematopoietic': [], 'Skin': [], 'Central Nervous System': [], 'Thyroid': [],
                'Nervous System': [], 'Lungs': [], 'Joints': [], 'Metabolism': [], 'Gastrointestinal': [], 
                'Muscles': [], 'Blood': [], 'Eyes': [], 'Reproductive': [], 'ENT': [] 
            };
            // Updated to store ARRAYS of names, not just counts
            const carcinogenCount = { 'Possible': [], 'Yes': [] };
            const neurotoxinCount = { 'Possible': [], 'Yes': [] };

            if (!reportData || !dictionaryData) {
                alert('Analysis failed. Ensure the dictionary is loaded and the report is parsed.');
                return;
            }

            reportData.forEach(reportItem => {
                const normalizedName = normalizeAnalyte(reportItem.Analyte);
                const dictEntry = dictionaryData.get(normalizedName);
                
                if (!dictEntry || isNaN(dictEntry.Ref_Value)) {
                    return;
                }

                const measurement = reportItem.Measurement;
                const reference = dictEntry.Ref_Value;
                const toxicityRatio = reference > 0 ? (measurement / reference) : 0;
                let status = 'IN-RANGE';
                
                if (toxicityRatio > 2.0) {
                    status = 'VERY_HIGH';
                } else if (toxicityRatio > 1.1) {
                    status = 'HIGH';
                } else if (toxicityRatio > 1.0) {
                    status = 'ELEVATED';
                }

                // If flagged, collect the risks
                if (status === 'HIGH' || status === 'VERY_HIGH' || status === 'ELEVATED') {
                    const analyteName = dictEntry.Analyte;
                    
                    // Collect Analyte Names for Organ Systems
                    [dictEntry.Organ_System_1, dictEntry.Organ_System_2].forEach(system => {
                        const cleanSystem = cleanText(system);
                        if (cleanSystem && cleanSystem !== '-' && riskTally[cleanSystem] !== undefined) {
                            // Only push the name if it's not already listed for this system
                            if (!riskTally[cleanSystem].includes(analyteName)) {
                                riskTally[cleanSystem].push(analyteName);
                            }
                        }
                    });

                    // Tally and Collect names for Carcinogen Risk
                    const carcinogenStatus = cleanText(dictEntry.Carcinogen).toLowerCase();
                    if (carcinogenStatus.startsWith('yes')) {
                        if (!carcinogenCount.Yes.includes(analyteName)) carcinogenCount.Yes.push(analyteName);
                    } else if (carcinogenStatus.startsWith('possible')) {
                        if (!carcinogenCount.Possible.includes(analyteName)) carcinogenCount.Possible.push(analyteName);
                    }
                    
                    // Tally and Collect names for Neurotoxin Risk
                    const neurotoxinStatus = cleanText(dictEntry.Neurotoxin).toLowerCase();
                    if (neurotoxinStatus.startsWith('yes')) {
                        if (!neurotoxinCount.Yes.includes(analyteName)) neurotoxinCount.Yes.push(analyteName);
                    } else if (neurotoxinStatus.startsWith('possible')) {
                        if (!neurotoxinCount.Possible.includes(analyteName)) neurotoxinCount.Possible.push(analyteName);
                    }
                }
                
                // Store result
                analysisResults.push({
                    Analyte: dictEntry.Analyte,
                    Measurement: measurement + ' ' + dictEntry.Unit,
                    Ref_Value: reference + ' ' + dictEntry.Unit,
                    Status: status,
                    ToxicityRatio: toxicityRatio.toFixed(2) + 'x',
                    Key_Health_Effect: dictEntry.Key_Health_Effect || 'N/A',
                    Primary_Source: dictEntry.Primary_Source || 'N/A',
                    Carcinogen: dictEntry.Carcinogen,
                    Neurotoxin: dictEntry.Neurotoxin,
                    Organ_System_1: dictEntry.Organ_System_1,
                    Organ_System_2: dictEntry.Organ_System_2,
                });
            });

            // Display results
            displayAnalyteTable();
            displayRiskSummary(riskTally, carcinogenCount, neurotoxinCount);
            document.getElementById('results').style.display = 'block';
        }

        // --- Display Functions (Updated to List Toxin Names for ALL Categories) ---

        function displayAnalyteTable() {
            const tableBody = document.getElementById('analyteTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ''; 

            analysisResults
                .sort((a, b) => parseFloat(b.ToxicityRatio) - parseFloat(a.ToxicityRatio)) // Sort by highest ratio first
                .forEach(result => {
                const row = tableBody.insertRow();
                const statusClass = `status-${result.Status.replace(/[\s-]/g, '_').toUpperCase()}`;

                row.insertCell().textContent = result.Analyte;
                row.insertCell().textContent = result.Measurement;
                row.insertCell().textContent = result.Ref_Value;
                row.insertCell().innerHTML = `<span class="${statusClass}">${result.Status.replace(/_/g, ' ')}</span>`;
                row.insertCell().textContent = result.ToxicityRatio;
                row.insertCell().textContent = result.Key_Health_Effect;
                row.insertCell().textContent = result.Primary_Source;
            });
        }

        function displayRiskSummary(riskTally, carcinogenCount, neurotoxinCount) {
            const summaryDiv = document.getElementById('riskSummary');
            summaryDiv.innerHTML = '';
            
            // 1. Organ Burden Summary
            // Convert riskTally object to an array of [system, nameArray] pairs and filter/sort
            const sortedSystems = Object.entries(riskTally)
                .filter(([, nameArray]) => nameArray.length > 0)
                .sort(([, a], [, b]) => b.length - a.length); // Sort by count (length of array)

            if (sortedSystems.length > 0) {
                let systemHtml = '<h3>Organ System Burden (Tally of Flagged Toxins)</h3><ul>';
                sortedSystems.forEach(([system, nameArray]) => {
                    const toxinList = nameArray.join(', ');
                    systemHtml += `<li><strong>${system}:</strong> ${nameArray.length} Toxins Flagged: <span style="font-size: 0.9em; font-style: italic;">(${toxinList})</span></li>`;
                });
                systemHtml += '</ul>';
                summaryDiv.innerHTML += systemHtml;
            } else {
                summaryDiv.innerHTML += '<p>No toxins were flagged above the reference value (1.1x) to calculate organ burden.</p>';
            }

            // 2. Critical Risk Summary (Updated to list names)
            let riskHtml = '<h3>Critical Toxicity Flags</h3><ul>';
            
            const yesCarcinogens = carcinogenCount.Yes;
            const possibleCarcinogens = carcinogenCount.Possible;
            const yesNeurotoxins = neurotoxinCount.Yes;
            const possibleNeurotoxins = neurotoxinCount.Possible;
            
            const totalCriticalFlags = yesCarcinogens.length + possibleCarcinogens.length + yesNeurotoxins.length + possibleNeurotoxins.length;

            if (yesCarcinogens.length > 0) {
                riskHtml += `<li><strong>Known Carcinogens (${yesCarcinogens.length}):</strong> <span style="font-size: 0.9em; font-style: italic;">(${yesCarcinogens.join(', ')})</span></li>`;
            }
            
            if (possibleCarcinogens.length > 0) {
                riskHtml += `<li><strong>Possible Carcinogens (${possibleCarcinogens.length}):</strong> <span style="font-size: 0.9em; font-style: italic;">(${possibleCarcinogens.join(', ')})</span></li>`;
            }
            
            if (yesNeurotoxins.length > 0) {
                riskHtml += `<li><strong>Known Neurotoxins (${yesNeurotoxins.length}):</strong> <span style="font-size: 0.9em; font-style: italic;">(${yesNeurotoxins.join(', ')})</span></li>`;
            }
            
            if (possibleNeurotoxins.length > 0) {
                riskHtml += `<li><strong>Possible Neurotoxins (${possibleNeurotoxins.length}):</strong> <span style="font-size: 0.9em; font-style: italic;">(${possibleNeurotoxins.join(', ')})</span></li>`;
            }

            if (totalCriticalFlags === 0 && sortedSystems.length > 0) {
                riskHtml += '<li>No highly critical (Carcinogen/Neurotoxin) toxins were flagged.</li>';
            } else if (totalCriticalFlags === 0 && sortedSystems.length === 0) {
                riskHtml += '<li>No toxins were flagged above the reference value.</li>';
            }
            riskHtml += '</ul>';
            summaryDiv.innerHTML += riskHtml;
        }

        // --- Control Flow ---

        function checkReady() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            // Check that the dictionary is loaded AND the report data has been extracted
            if (dictionaryData && reportData && reportData.length > 0) {
                analyzeBtn.style.display = 'block';
            } else {
                analyzeBtn.style.display = 'none';
            }
        }
        
        // --- PDF Generation Logic (Updated to show Toxin Names) ---

        const executePdfDownload = () => {
             if (!analysisResults || analysisResults.length === 0) {
                 alert("Please run the analysis first.");
                 return;
             }
             
             try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('p', 'pt', 'a4');
                const margin = 40;
                let finalY = margin;

                // Title
                doc.setFontSize(18);
                doc.setTextColor('#8B0000');
                doc.text("Environmental Toxin Analysis Report", margin, finalY);
                finalY += 30;

                // --- Summary Data Setup (Recalculate Tally with Names) ---
                const riskData = [];
                const riskTally = {}; // Object to collect names for organ systems
                const criticalTally = { 'carc_yes': [], 'carc_possible': [], 'neuro_yes': [], 'neuro_possible': [] }; // Object to collect critical names

                analysisResults.filter(r => r.Status !== 'IN-RANGE').forEach(r => {
                    const analyteName = r.Analyte;
                    
                    // 1. Organ System Tally
                    [r.Organ_System_1, r.Organ_System_2].forEach(system => {
                        const cleanSystem = cleanText(system);
                        if (cleanSystem && cleanSystem !== '-') {
                            if (!riskTally[cleanSystem]) riskTally[cleanSystem] = [];
                            if (!riskTally[cleanSystem].includes(analyteName)) {
                                riskTally[cleanSystem].push(analyteName);
                            }
                        }
                    });

                    // 2. Critical Tally
                    const carcStatus = cleanText(r.Carcinogen).toLowerCase();
                    const neuroStatus = cleanText(r.Neurotoxin).toLowerCase();

                    if (carcStatus.startsWith('yes') && !criticalTally.carc_yes.includes(analyteName)) {
                        criticalTally.carc_yes.push(analyteName);
                    } else if (carcStatus.startsWith('possible') && !criticalTally.carc_possible.includes(analyteName)) {
                        criticalTally.carc_possible.push(analyteName);
                    }
                    
                    if (neuroStatus.startsWith('yes') && !criticalTally.neuro_yes.includes(analyteName)) {
                        criticalTally.neuro_yes.push(analyteName);
                    } else if (neuroStatus.startsWith('possible') && !criticalTally.neuro_possible.includes(analyteName)) {
                        criticalTally.neuro_possible.push(analyteName);
                    }
                });


                // --- Organ Burden Summary Table ---
                doc.setFontSize(14);
                doc.setTextColor('#333');
                doc.text("Organ System Burden Summary", margin, finalY);
                finalY += 15;
                
                const sortedSystems = Object.entries(riskTally)
                    .filter(([, nameArray]) => nameArray.length > 0)
                    .sort(([, a], [, b]) => b.length - a.length);
                    
                if (sortedSystems.length > 0) {
                    sortedSystems.forEach(([system, nameArray]) => {
                        // Toxin list split across two rows for better PDF formatting
                        const toxinList = nameArray.join(', ');
                        riskData.push(
                            [system, `${nameArray.length} Toxins Flagged`],
                            [{ content: `Toxins: ${toxinList}`, colSpan: 2, styles: { fontStyle: 'italic', fontSize: 7, textColor: '#777' } }]
                        );
                    });
                    
                    doc.autoTable({
                        startY: finalY + 5,
                        head: [['Organ System', 'Burden Count']],
                        body: riskData,
                        theme: 'grid',
                        headStyles: { fillColor: '#F0E6E6', textColor: '#555' },
                        columnStyles: { 0: { fontStyle: 'bold' } }
                    });
                    finalY = doc.lastAutoTable.finalY + 10;
                } else {
                    doc.text("No toxins were flagged above 1.1x the reference value.", margin, finalY + 5);
                    finalY += 20;
                }
                
                // --- Critical Risk Summary Table (Updated to show names) ---
                doc.setFontSize(14);
                doc.text("Critical Toxicity Flags", margin, finalY);
                finalY += 15;
                
                const criticalData = [];
                
                if (criticalTally.carc_yes.length > 0) {
                    criticalData.push(
                        ['Known Carcinogen Risk', `${criticalTally.carc_yes.length} Toxins`],
                        [{ content: `Toxins: ${criticalTally.carc_yes.join(', ')}`, colSpan: 2, styles: { fontStyle: 'italic', fontSize: 7, textColor: '#8B0000' } }]
                    );
                }
                if (criticalTally.carc_possible.length > 0) {
                    criticalData.push(
                        ['Possible Carcinogen Risk', `${criticalTally.carc_possible.length} Toxins`],
                        [{ content: `Toxins: ${criticalTally.carc_possible.join(', ')}`, colSpan: 2, styles: { fontStyle: 'italic', fontSize: 7, textColor: '#A52A2A' } }]
                    );
                }
                if (criticalTally.neuro_yes.length > 0) {
                    criticalData.push(
                        ['Known Neurotoxin Risk', `${criticalTally.neuro_yes.length} Toxins`],
                        [{ content: `Toxins: ${criticalTally.neuro_yes.join(', ')}`, colSpan: 2, styles: { fontStyle: 'italic', fontSize: 7, textColor: '#8B0000' } }]
                    );
                }
                if (criticalTally.neuro_possible.length > 0) {
                    criticalData.push(
                        ['Possible Neurotoxin Risk', `${criticalTally.neuro_possible.length} Toxins`],
                        [{ content: `Toxins: ${criticalTally.neuro_possible.join(', ')}`, colSpan: 2, styles: { fontStyle: 'italic', fontSize: 7, textColor: '#A52A2A' } }]
                    );
                }

                if (criticalData.length > 0) {
                    doc.autoTable({
                        startY: finalY + 5,
                        head: [['Risk Factor', 'Toxin Count']],
                        body: criticalData,
                        theme: 'grid',
                        headStyles: { fillColor: '#F0E6E6', textColor: '#555' },
                        columnStyles: { 1: { fontStyle: 'bold', halign: 'center' } }
                    });
                    finalY = doc.lastAutoTable.finalY + 20;
                } else {
                    // Placeholder if no critical flags exist
                    doc.text("No critical (Carcinogen/Neurotoxin) toxins were flagged above 1.1x the reference value.", margin, finalY + 5);
                    finalY += 20;
                }


                // --- Detailed Analyte Results Table ---
                doc.setFontSize(18);
                doc.text("Detailed Analyte Results", margin, finalY);
                finalY += 15;

                const tableData = analysisResults.map(r => [
                    r.Analyte,
                    r.Measurement,
                    r.Ref_Value,
                    r.Status.replace(/_/g, ' '),
                    r.ToxicityRatio,
                    r.Key_Health_Effect,
                    r.Primary_Source
                ]);
                
                const head = [['Analyte', 'Measurement', 'Reference (ULN)', 'Status', 'Ratio (M/R)', 'Key Health Effect', 'Primary Source']];

                doc.autoTable({
                    startY: finalY + 5,
                    head: head,
                    body: tableData,
                    theme: 'grid',
                    styles: { fontSize: 8 },
                    headStyles: { fillColor: '#8B0000', textColor: '#FFF' },
                    columnStyles: { 
                        3: { cellWidth: 50 },
                        4: { cellWidth: 40 },
                    },
                    didParseCell: function(data) {
                        if (data.section === 'body' && data.column.dataKey === 3) { // Status column
                            let statusText = data.cell.text.join('');
                            let textColor = '#333'; 
                            
                            if (statusText.includes('VERY HIGH')) { textColor = '#8B0000'; // Dark Red
                            } else if (statusText.includes('HIGH')) { textColor = '#ff8c00'; // Orange
                            } else if (statusText.includes('ELEVATED')) { textColor = '#ffd700'; // Yellow
                            } else if (statusText.includes('IN RANGE')) { textColor = '#28a745'; // Green 
                            }
                            doc.setTextColor(textColor); 
                        }
                    },
                    didDrawPage: function(data) {
                        doc.setTextColor('#333');
                    }
                });
                
                doc.save("toxin_risk_analysis_report.pdf");
             } catch (e) {
                 console.error("PDF Generation Error:", e);
                 alert("PDF generation failed. Check the console for error details.");
             }
        };


        // --- Event Listeners and Initialization ---
        
        document.getElementById('reportFile').addEventListener('change', loadReport);
        document.getElementById('analyzeBtn').addEventListener('click', evaluateAnalytes);
        document.getElementById('downloadPdfBtn').addEventListener('click', executePdfDownload);
        
        // THIS LINE IS THE FIX: Automatically load the dictionary when the page finishes loading
        window.onload = loadDictionary; 
    </script>
</body>
</html>